/**
 * Automatic Route Creation API
 * System-generated optimized routes
 */

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { logAudit } from '@/lib/audit';

export const dynamic = 'force-dynamic';

/**
 * POST /api/admin/routes/auto-create
 * Automatically create optimized routes from pending drops
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user || (session.user as any).role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { 
      maxDropsPerRoute = 10,
      maxDistanceKm = 50,
      serviceTier = null,
      autoAssignDrivers = false,
    } = body;

    // Get all pending drops
    const pendingDrops = await prisma.drop.findMany({
      where: {
        status: 'pending',
        routeId: null,
        ...(serviceTier && { serviceTier }),
      },
      select: {
        id: true,
        customerId: true,
        pickupAddress: true,
        deliveryAddress: true,
        timeWindowStart: true,
        timeWindowEnd: true,
        quotedPrice: true,
        weight: true,
        volume: true,
        serviceTier: true,
        status: true,
        // Remove estimatedDuration to avoid database error
        Booking: {
          select: {
            customerName: true,
            customerEmail: true,
          }
        }
      },
      orderBy: { timeWindowStart: 'asc' },
      take: 100, // Process in batches
    });

    if (pendingDrops.length === 0) {
      return NextResponse.json({
        success: true,
        message: 'No pending drops available',
        routesCreated: 0,
      });
    }

    // Simple clustering algorithm: group by time window and proximity
    const routes: any[] = [];
    let currentGroup: typeof pendingDrops = [];
    let currentTime = pendingDrops[0].timeWindowStart;

    for (const drop of pendingDrops) {
      // Check if drop fits in current group
      const timeDiff = Math.abs(drop.timeWindowStart.getTime() - currentTime.getTime()) / (1000 * 60 * 60);
      
      if (currentGroup.length >= maxDropsPerRoute || timeDiff > 4) {
        // Time difference > 4 hours, create new group
        if (currentGroup.length > 0) {
          routes.push(currentGroup);
        }
        currentGroup = [drop];
        currentTime = drop.timeWindowStart;
      } else {
        currentGroup.push(drop);
      }
    }

    // Add last group
    if (currentGroup.length > 0) {
      routes.push(currentGroup);
    }

    // Get available drivers if auto-assign is enabled
    let availableDrivers: any[] = [];
    if (autoAssignDrivers) {
      availableDrivers = await prisma.driver.findMany({
        where: {
          status: 'active',
          DriverAvailability: { status: 'online' }
        },
        include: {
          User: { select: { name: true } }
        },
        take: routes.length,
      });
    }

    // Create routes
    const createdRoutes = [];
    for (let i = 0; i < routes.length; i++) {
      const dropGroup = routes[i];
      const totalOutcome = dropGroup.reduce((sum: number, d: any) => sum + Number(d.quotedPrice || 0), 0);
      const totalWeight = dropGroup.reduce((sum: number, d: any) => sum + (d.weight || 0), 0);
      const totalVolume = dropGroup.reduce((sum: number, d: any) => sum + (d.volume || 0), 0);
      const assignedDriver = autoAssignDrivers && availableDrivers[i] ? availableDrivers[i] : null;

      const route = await prisma.route.create({
        data: {
          driverId: assignedDriver?.id || null,
          status: assignedDriver ? 'assigned' : 'planned',
          startTime: dropGroup[0].timeWindowStart,
          timeWindowStart: dropGroup[0].timeWindowStart,
          timeWindowEnd: dropGroup[dropGroup.length - 1].timeWindowEnd,
          serviceTier: dropGroup[0].serviceTier || 'standard',
          totalDrops: dropGroup.length,
          completedDrops: 0,
          totalOutcome,
          maxCapacityWeight: totalWeight,
          maxCapacityVolume: totalVolume,
          routeOptimizationVersion: '2.0',
          routeNotes: 'Automatically generated by system',
          routeComplexityScore: Math.min(dropGroup.length, 5),
        }
      });

      // Update drops
      await prisma.drop.updateMany({
        where: { id: { in: dropGroup.map((d: any) => d.id) } },
        data: {
          routeId: route.id,
          status: 'assigned_to_route',
        }
      });

      // Log optimization history
      // Optional: routeOptimizationHistory table may not exist in schema
      /* await prisma.routeOptimizationHistory.create({
        data: {
          routeId: route.id,
          optimizationType: 'initial',
          algorithmVersion: '2.0',
          inputParameters: {
            maxDropsPerRoute,
            maxDistanceKm,
            autoAssignDrivers,
          },
          optimizationResult: {
            dropsCount: dropGroup.length,
            estimatedDuration: dropGroup.length * 30, // 30 min per drop estimate
            totalValue: totalOutcome,
          },
          createdBy: (session.user as any).id,
        }
      }); */

      createdRoutes.push({
        ...route,
        driverName: assignedDriver?.User?.name || 'Unassigned',
        dropCount: dropGroup.length,
      });
    }

    await logAudit(
      (session.user as any).id,
      'auto_create_routes',
      undefined,
      { 
        targetType: 'route', 
        after: { 
          routesCreated: createdRoutes.length,
          totalDrops: pendingDrops.length,
          autoAssignDrivers,
        }
      }
    );

    return NextResponse.json({
      success: true,
      message: `Successfully created ${createdRoutes.length} optimized routes from ${pendingDrops.length} pending drops`,
      routesCreated: createdRoutes.length,
      routes: createdRoutes,
    });

  } catch (error) {
    console.error('‚ùå Auto-create routes error:', error);
    return NextResponse.json(
      { 
        success: false,
        error: 'Failed to auto-create routes',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}







